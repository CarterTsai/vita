#!snabb snsh

-- Use of this source code is governed by the GNU AGPL license; see COPYING.

local gentest = require("program.vita.gentest")
local counter = require("core.counter")
local Intel = require("apps.intel_mp.intel_mp").Intel
local ARP = require("apps.ipv4.arp").ARP
local Sink = require("apps.basic.basic_apps").Sink
local Synth = require("apps.test.synth").Synth
local RateLimiter = require("apps.rate_limiter.rate_limiter").RateLimiter
local ethernet= require("lib.protocol.ethernet")
local ipv4 = require("lib.protocol.ipv4")
local datagram = require("lib.protocol.datagram")
local numa = require("lib.numa")
local S = require("syscall")

-- Synopsis:
--
--    realtest.snabb <pciaddr> <macaddr> <ip> <nh> \
--       [<duration>] [<pktsize>|IMIX] [<gbps>] [<nroutes>] [<prefix>] [<cpu>]
--
--     Default is 10 seconds at 10 Gbps IMIX via one route with prefix 172.16.
--
-- This hardware-based benchmarking design for Vita simulates a private
-- next-hop suitable for evaluating Vita performance in a realistic setting.
-- Its synthesized traffic is rate limited to facilitate testing varying
-- traffic levels. It is supposed to be used in a mirrored fashion; i.e., in a
-- topology like so
--
--    realtest(A) <-> Vita(A) <-> Vita(B) <-> realtest(B)
--
-- ...where <pciaddr>, <macaddr> and <ip> denote realtest(A), <nh> is the
-- private IP address of Vita(A). Subsequently, three interconnected pairs of
-- (possibly virtualized) NIC ports are required to test Vita using two
-- opposing instances of realtest. The Vita node to be tested must be
-- configured accordingly for routes <prefix>.N.0/24 with SPI 1000+N with
-- all-zero keys for N from 1 to <nroutes>.
--
-- Here is a diagram of the app graph implemented:
--
--          +------------+        +---------+
--          |            | output |         |
--          |  RateLim   <--------+  Synth  |
--          |            |        |         |
--          +-----+------+        +---------+
--                |
--                |                      +----------+
--                |  +--------+          |          |
--                |  |        |  +------->          +--->
--                +-->        +--+    ^  |          |
--          north    |  ARP   |    south |   NIC    |  (Vita private)
--                +--+        <--+    .  |          |
--                |  |        |  +-------+          <----
--                |  +--------+     ^ .  |          |
--                |                 . .  +----------+
--                |                 . .
--            +---v----+            . .
--            |        |    RX/TX measured here
--            |  Sink  |
--            |        |
--            +--------+
--
-- A realtest instance measures and reports throughput at the NIC driver edge.
-- The reported ingress rate corresponds to the amount of traffic received
-- from the opposing realtest instance (i.e., end-to-end.)
--
-- For a simpler test case with minimal demands see: test.snabb

local pciaddr = assert(main.parameters[1], "Need pciaddr")
local macaddr = assert(main.parameters[2], "Need macaddr")
local ip = assert(main.parameters[3], "Need ip")
local nh = assert(main.parameters[4], "Need nh")
local duration = tonumber(main.parameters[5]) or 10
local pktsize = tonumber(main.parameters[6]) or main.parameters[6]
local rate = math.floor(tonumber(main.parameters[7] or 10)*1e9/8)
local nroutes = tonumber(main.parameters[8])
local route_prefix = main.parameters[9]
local cpu = tonumber(main.parameters[10])

numa.bind_to_cpu(cpu)

local c = config.new()

config.app(c, "nic", Intel, {pciaddr=pciaddr, macaddr=macaddr, vmdq=true})
config.app(c, "arp", ARP, {self_mac=ethernet:pton(macaddr),
                           self_ip=ipv4:pton(ip),
                           next_ip=ipv4:pton(nh)})
config.link(c, "nic.output -> arp.south")
config.link(c, "arp.south -> nic.input")

local _, sim_packets = gentest.gen_testcase({
      private_nexthop_ip4 = ip,
      route_prefix = route_prefix,
      nroutes = nroutes,
      packet_size = pktsize
})
config.app(c, "synth", Synth, {packets=sim_packets})
config.app(c, "rate", RateLimiter, {rate=rate, bucket_capacity=rate})
config.link(c, "synth.output -> rate.input")
config.link(c, "rate.output -> arp.north")

config.app(c, "sink", Sink)
config.link(c, "arp.north -> sink.input")

engine.configure(c)

engine.main({duration=duration, report={showlinks=true}})


local name = ("realtest[%d]"):format(S.getpid())

local dst_link = engine.app_table.nic.input.input
local src_link = engine.app_table.nic.output.output

local txpackets = tonumber(counter.read(dst_link.stats.txpackets))
local txbytes = tonumber(counter.read(dst_link.stats.txbytes))
print(("%s: Sent %.1f million packets in %.2f seconds (%d bytes; %.2f Gbps)")
      :format(name, txpackets/1e6, duration, txbytes, txbytes*8/1e9/duration))
print(("%s: TX Rate(Mpps):\t%.3f"):format(name, txpackets/duration/1e6))

local rxpackets = tonumber(counter.read(src_link.stats.txpackets))
local rxbytes = tonumber(counter.read(src_link.stats.txbytes))
print(("%s: Received %.1f million packets in %.2f seconds (%d bytes; %.2f Gbps)")
      :format(name, rxpackets/1e6, duration, rxbytes, rxbytes*8/1e9/duration))
print(("%s: RX Rate(Mpps):\t%.3f"):format(name, rxpackets/duration/1e6))
